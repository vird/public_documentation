## General Program Structure

Traditional C programs have one main function, which in turn calls other functions. Contracts look more like classes with multiple functions, callable from outside. Also, for more similarity, each contract has its own memory (it is called **persistent** in TVM).

So, a typical contract in C has no main function, but has several public methods, and several persistent variables.

## Public methods

A function becomes a public method for contract X, if it is declared in the **X.abi** file.

## Global and persistent variables

Programs written in C language call code once: before the code starts working all data is initialized; after execution is over, all data is disposed of. As far as contracts are concerned, they retain their state between contract methods invocations. So there are two different types of global variables:

- traditional global C variables are forgotten after the method stops working;
- persistent variables, which are stored in blockchain; these values remain (persist) between method invocations.

Global variables can be made persistent by adding the *_persistent* postfix:

```Scala
int x = 0;             // Forgotten after each method invocation
int y_persistent = 0;  // Kept in blockchain and does not lose its value
```

## Low-Level Implementation Details

The above primitives are written by TON Labs team, and TVM does not really impose this format of communication. In fact, a contract has a single entry point. When a request (message) is made it, a slice (that is, a bit string) is provided along with it.

A low-level part of the TON standard library contains a **selector:** a special function that parses a slice and calls a given contract method. Method selection is determined by a method id specified in the initial bytes of the slice. The remaining slice elements are stored into a working slice.

Contract methods are generated by a special script according to an abi file. Then they are put into a **X_wrapper.c file**, where X is the name of the contract. These methods *deserialize* parameters from a *slice* and transfer them as parameters to the proper contract function implementation.

## Library Structure

The library is a set of files that have to be included into your contract code directly or indirectly to implement predefined C structures. These structures are designed to ensure smoother development of code that can be compiled to TVM Assembly.

For learning purposes, we provide a commented sample contract that shows how library files are included in it, how they work, and how the code is written with regard to it. This contract is a blockchain transfer transaction designed for a Piggy Bank dapp.

Note that the library has a cross-reference structure. In other words, files, included into the final smart contract (.h headers with declarations), in turn, include other files (.inc with definitions) from the library.

Also, there are .inc or .c files that contain implementations for declarations and definitions. But, these are not included into other files or into the contract itself.

The file naming convention indicates that there are files implementing the TON-compatible C structures, messaging logic, contract data (fields) and files that allow defining TVM-specific components in C.

The **arguments.h** file enables faster function argument parsing without introducing additional structures.

## Inclusion Pattern

### Detailed File Description

The sample smart contract includes several header files. Basically, they allow creating a valid version of a smart-contract.

Given follow-up library revisions and modifications, as well as project particularities, you may find that some files are redundant for you.

```Scala
#include "ton-sdk/tvm.h"
#include "ton-sdk/messages.h"
#include "ton-sdk/arguments.h"
#include "ton-sdk/smart-contract-info.h"
```

The body of the contract contains arguments that are parsed, business logic stored in permanent memory and the final message. The first part of the message is taken from the ABI protocol and the second is generated by the contract (big integer, 46 symbols).

### TVM.h

The **tvm.h** file declares general C structures.

**Note**: Bodies of functions for value manipulation are implemented in the **tvm.c** file, which is compiled along with your source files and linked to the resulting contract binary file.

### smart-contract-info.h, smart-contract-info.inc, define-ton-structure-header.inc

The **smart-contract-info.h** header file defines SmartContractInfo TON-specific structure. The fields of the structure are declared in **smart-contract-info.inc** file. File **define-ton-structure-header.inc** contains some helper macroses, which declare:

- **SmartContractInfo** structure by itself
- builder and cell serialization functions
- slice and cell deserialization functions

> **Note**: Please, refer to the TVM specification for more info on the concept of *bag of cells*, cell serialization and slice deserialization.

The **smart-contract-info.inc** defines the contract field structure in the TON_STRUCT macro. The macro lists the supported fields with names, lengths and types.

```Scala
#define TON_STRUCT_NAME SmartContractInfo
#define TON_STRUCT \\
    FIELD_CONSTANT_UNSIGNED(smc_info, 0x076ef1ea, 32) \\
    FIELD_UNSIGNED(actions, 16) \\
    FIELD_UNSIGNED(msgs_sent, 16) \\
    FIELD_UNSIGNED(unixtime, 32) \\
    FIELD_UNSIGNED(block_lt, 64) \\
    FIELD_UNSIGNED(trans_lt, 64) \\
    FIELD_UNSIGNED(rand_seed, 256) \\
    FIELD_COMPLEX(balance_remaining, CurrencyCollection) \\
    FIELD_COMPLEX(myself, MsgAddressInt)
#include HEADER_OR_C
#undef HEADER_OR_C 
```

Below is field declarations and macroses in the above code are explained:

- The first line defines the structure name, **SmartContractInfo** (this macro is used in many points where structure name is necessary).
- **FIELD_CONSTANT_UNSIGNED** macro defines a constant ("virtual") field which is not really stored within a structure, but its value is placed into a slice at serialization and checked at deserialization.
- **FIELD_UNSIGNED** no in-depth explanation needed.
- **FIELD_COMPLEX** allows to define a nested structure.
- **HEADER_OR_C** macro includes either source or header file depending on the context. This macro is undefined after use to allow declaring the next structure in file (if exists) without warnings that a macro is already declared.

This complicated system of includes and macroses defines a lot of useful functions and structures. For example, the function below from the contract returns balance information in compliance with the structure defined in the macro.

```Scala
SmartContractInfo sc_info = get_SmartContractInfo();
int balance = sc_info.balance_remaining.grams.amount; 
```

### message.h and message.inc

The **message.h** file declares a macro to enable messaging procedures. In refers to the **message.inc** file where actual messaging rules are defined.

The **message.inc** maps messaging rules to structures and fields declared in the **tvm.h** and **define-ton-struct-header.inc** files.

The **arguments.h** file is covered above.

## Notes on the ABI 

Contract messages in TON Labs contracts are formatted according to ABI specifications. Currently only (u)int values are supported.