## Contract Development Flow



This is an ironical guide to smart contract development created by a writer for developers. Use it as a roadmap and keep smiling while on the way ; ). 

## def develop_code():

&nbsp;&nbsp;**If** you want to start with TON smart contracts:

- Check the current [ABI Spec]()

// Contract life-cycle is basically a constant message exchange. Messages are used to address contract public functions and trigger transactions that change the contract state and to get contract data without changing its state. The message format in TON is based on the specification and rules for interaction with a specific contract are defined by its ABI. So before you start, check the ABI spec.

- Check the general info on how [Gas is calculated in TON]() in general and for [transaction]()</br>
- Check how you can [manage gas in your contract]()</br>
- Check how you can [modify code of a deployed contract]()</br>
- Check our documents on [Solidity language feature implementation](Compilers/Solidity Compiler/Solidity Support Status)</br>
- Create your code now in Solidity, C, C++ 

&nbsp;&nbsp;&nbsp;&nbsp;**result** = code.

&nbsp;&nbsp;**return** result

## def install_tools(preferred delivery):

// To start you need to build your compilation and deployment toolchain there are several options.

&nbsp;&nbsp;**if** preferred delivery option: source code from open source:
&nbsp;&nbsp;&nbsp;&nbsp;**then** get the needed components: 

- ​     [Solidity Compiler](https://github.com/tonlabs/TON-Solidity-Compiler)</br>
- ​     [LLVM Compiler]( https://github.com/tonlabs/TON-Compiler)</br>
- ​     [tvm-linker utility](https://github.com/tonlabs/TVM-linker) 

&nbsp;&nbsp;&nbsp;&nbsp;Follow guidelines in Readme's to build a toolchain

&nbsp;&nbsp;&nbsp;&nbsp;**result** = working toolchain

&nbsp;&nbsp;**elif** preferred delivery option TON Labs SDK/Node SE from containers:

&nbsp;&nbsp;&nbsp;&nbsp;**then** install the SDK/Node SE according to the [guidelines](SDK/Installation).

&nbsp;&nbsp;&nbsp;&nbsp;**result** =  working toolchain with a [CLI](SDK/TONDEV CLI)

&nbsp;&nbsp;**else** preferred delivery option  SDK/Node SE from sources:

&nbsp;&nbsp;&nbsp;&nbsp;**then** get sources:

- ​     [the SDK core]( https://github.com/tonlabs/TON-SDK )</br>
- ​     [TVM]( https://github.com/tonlabs/ton-labs-vm)</br>
- ​     [JS Library]( https://github.com/tonlabs/ton-client-js )</br>
- ​     [Rust Library](https://github.com/tonlabs/ton-client-rs) 

&nbsp;&nbsp;&nbsp;&nbsp;Follow guidelines in Readme's to create a project 

&nbsp;&nbsp;&nbsp;&nbsp;**result** = working toolchain with a CLI 

&nbsp;&nbsp;**return** **result**

## def compilation(smart contract source):

  smart contract source == **Solidity**

// You need to compile the source code and there are several options depending on compiler preferences and source language.

&nbsp;&nbsp; **if** compiler toolchain built from <u>source code</u>:

&nbsp;&nbsp;&nbsp;&nbsp; **then** call:

​       `tvm_linker compile [--lib <lib_file>] [--abi-json <abi_file>] [--genkey | --setkey <keyfile>] [-w <workchain_id>] [--debug] <source>`

&nbsp;&nbsp;&nbsp;&nbsp;**result** = .tvc file

 // Note that if you use this compilation option, you get the key pair and the future contract address after compilation. You can still change the address at contract deployment and initialization via the SDK. 

&nbsp;&nbsp;**elif**  compiler built from SDK/Node SE containers:

&nbsp;&nbsp;&nbsp;&nbsp;**then** call the CLI command: `tondev sol`

&nbsp;&nbsp;&nbsp;&nbsp;**result** = .tvc file

// With this option the future address is unknown.

&nbsp;&nbsp;**else** compiler built from  SDK /Node SE raw sources:

*​      then [TODO]*

  smart contract source == C/C++:

&nbsp;&nbsp; **if** compiler built from <u>source code</u>:

&nbsp;&nbsp;&nbsp;&nbsp;**then** call:

​        `tvm_linker compile [--lib <lib_file>] [--abi-json <abi_file>] [--genkey | --setkey <keyfile>] [-w <workchain_id>] [--debug] <source>`

&nbsp;&nbsp;&nbsp;&nbsp; **result** = .tvc file

 // Note that if you use this compilation option, you get the key pair and the future contract address after compilation. You can still change the address at contract deployment and initialization via the SDK.

&nbsp;&nbsp;**elif** compiler built from SDK/Node SE pre-build container:

​    *[TODO]*

&nbsp;&nbsp;&nbsp;&nbsp;**result** = .tvc file 

// Note that with this option the future address unknown.

&nbsp;&nbsp;**else** compiler built from SDK raw sources:

​         [TODO]  

&nbsp;&nbsp;**return** result

## def get_boc(contract-address):

 //The option available for .tvc. files generated by the tvm_linker (they have an address in the name). You need .boc files to work directly with TON testnet and lite client. 

&nbsp;&nbsp;**call**:

`
tvm_linker message <contract-address> [--init] [--data] [-w]
`

&nbsp;&nbsp;**result** = .boc file

**return result**

## def get address(.tvc):

//You need this function to get a future contract address when you used the SDK locally. In this case createDeployMessage is used. See [more here](SDK/SDK API/Contract Management).

createDeployMessage with the [SDK library](SDK/Client Libraries/Using Libraries/Node.js)

&nbsp;&nbsp;&nbsp;&nbsp;**result** = address

 &nbsp;&nbsp;&nbsp;&nbsp;**return** result 

## def positive balance(address):

//In TON you cannot deploy to an address with zero balance due to storage fees. See more in Gas Specs.

 Use any available Giver to top up the address **OR** transfer tokens to the address from an active contract you have

&nbsp;&nbsp;&nbsp;&nbsp;**result** = positive balance

&nbsp;&nbsp;**return** result

## def deployment(compiled code):

//You can use one of the options depending on your preferences and on the compilation option you used before.

&nbsp;&nbsp;&nbsp;&nbsp; **if** compiled code is .tvc built from open source compilers

 &nbsp;&nbsp;&nbsp;&nbsp;  **then** use tvm_linker deployment command from the project folder.

 &nbsp;&nbsp;&nbsp;&nbsp; ** result** = contract deployed to address

&nbsp;&nbsp; **if**  compiled code is .tvc and contractPackage.js built by the SDK:

&nbsp;&nbsp;&nbsp;&nbsp;**then**  create the deploy message in JS OR Rust

&nbsp;&nbsp;&nbsp;&nbsp; **result** = contract deployed to address
  &nbsp;&nbsp;**return** result



